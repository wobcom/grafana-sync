use crate::api::dashboards::Folder;
use crate::error::GSError;
use crate::instance::GrafanaInstance;
use log::{debug, info};
use serde::Serialize;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize)]
struct FolderBody {
    description: String,
    title: String,
    uid: String,
}

impl GrafanaInstance {
    pub async fn get_all_folders(&self) -> Result<Vec<Folder>, GSError> {
        let endpoint = format!("{}{}", &self.base_url(), "/api/folders");
        let client = self.client();

        let response = client
            .get(endpoint)
            .query(&[("limit", "1000"), ("page", "1")])
            .send()
            .await?
            .error_for_status()?;
        let text = response.text().await?;

        Ok(serde_json::from_str::<Vec<Folder>>(&text)?)
    }

    // returns the folder uid on the instance
    pub async fn ensure_folder(&self, title: &str) -> Result<Folder, GSError> {
        debug!("Ensuring folder {} exists on {}...", title, self.base_url());
        let matching_folder = self
            .get_all_folders()
            .await?
            .into_iter()
            .filter(|f| f.title == title)
            .next();
        if let Some(folder) = matching_folder {
            debug!("Folder {} already exists", title);
            return Ok(folder);
        }

        let endpoint = format!("{}{}", &self.base_url(), "/api/folders");
        let client = self.client();

        let folder_body = FolderBody {
            description: "autogenerated by graphsync".to_string(),
            title: title.to_string(),
            // Could sync uid, but these folders might already exist so we're using a random one here
            // since it's not a reliable metric anyway
            uid: Uuid::new_v4().to_string(),
        };

        let response = client
            .post(endpoint)
            .json(&folder_body)
            .send()
            .await?
            .error_for_status()?;
        let text = response.text().await?;

        let folder = serde_json::from_str::<Folder>(&text)?;
        info!("Folder {} has been created", folder.title);

        Ok(folder)
    }
    
    pub async fn remove_folder(&self, uid: &str) -> Result<(), GSError> {
        let endpoint = format!(
            "{}{}",
            &self.base_url(),
            format!("/api/folders/{}", uid)
        );
        let client = self.client();

        debug!("Deleting folder with uid: {}", uid);

        client.delete(endpoint).send().await?.error_for_status()?;

        Ok(())
    }
    
    pub async fn remove_empty_folders(&self) -> Result<(), GSError> {
        let all_folders = self.get_all_folders().await?;

        for folder in all_folders {
            if self.get_dashboards_in_folder(&folder.uid).await?.is_empty() {
                info!("Deleting empty folder {}", folder.title);
                self.remove_folder(&folder.uid).await?;
            }
        }
        
        Ok(())
    }
}
